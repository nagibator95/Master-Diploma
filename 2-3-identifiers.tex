\section{Идентификаторы посылок}

Для решения проблемы отсутствия уникального идентификатора посылки было принято решение создать новую таблицу с посылками,
в которой доступ к посылок будет реализован с помощью уникального идентификатора -- поля "id". \label{lab:pynformatics_run_id}
Для сохранения однозначности между посылками Ejudge и записями в новой таблице, так же будут сохранены идентификаторы из Ejudge --
номер посылки (поле "ej\_run\_id") и номер контеста "ej\_contest\_id". 
Так же в рамках идеи о возможности использовать как нескольтко различных систем Edjuge, так и других тестирующих систем, 
сохраняется идентификатор текущей тестирующей системы (поле "ejudge\_url").

Для связи посылки с задачей для каждой посылки и для поиска посылок сохранятеся идентификатор задачи ("problem\_id").

Для связи с пользователем сохраняется идентификатор пользователя ("user\_id").

Также сохраняются результаты тестирования -- статус посылки ("ej\_status"), количество пройденных тестов ("ej\_test\_num"), набранный балл ("ej\_score") и другое.

Таким образом, схема таблицы посылок ("pynformatics.run") представляется в следующем виде:

\begin{center}
  \begin{longtable}{|p{0.20\textwidth}|p{0.20\textwidth}|p{0.5\textwidth}|}
    \caption{Схема таблицы pynformatics.run}
    \label{tab:longtable}
    \\ \hline
    Название & Тип данных & Комментарий \\
    \hline \endfirsthead
    \subcaption{Продолжение таблицы~\ref{tab:longtable}}
    \\ \hline \endhead
    \hline \subcaption{Продолжение на след. стр.}
    \endfoot
    \hline \endlastfoot
    id              & INTEGER     & Идентификатор посылки \\
    \hline
    ej\_run\_id     & INTEGER     & Номер посылки в ejudge \\
    \hline
    ej\_contest\_id & INTEGER     & Номер контеста в ejudge \\
    \hline
    ejudge\_url     & INTEGER     & Идентификатор тестирующей системы \\
    \hline
    user\_id        & INTEGER     & Идентификатор пользователя \\
    \hline
    problem\_id     & INTEGER     & Идентификатор задачи \\
    \hline
    ej\_status      & INTEGER     & Статус тестирования \\
    \hline
    ej\_test\_num   & INTEGER     & Количество пройденных тестов \\
    \hline
    ej\_score       & INTEGER     & Набранный балл \\
    \hline
  \end{longtable}
\end{center}

Однако при подходе с новой таблицей посылок появилась следующая проблема:
ejudge всё ещё пишет данные о результатах системы в свои таблицы БД ejudge
и не позволяет тривиально узнать о том, что посылка протестирована (подробнее рассмотрено в пункте \ref{chap:inotify}).

Решить эту проблему можно двумя способами:

\begin{itemize}
    \item создать специальный триггер в БД, который будет срабатывать при изменении результата тестирования;
    \item создать сервис, ждущий информации об обновлении посылки и каким-либо образом заставить ejudge отправлять сообщение при изменении статуса посылки, в таком случае сервис должен быть асинхронным, так как ejudge -- синхронен, и, если обновление посылки затянется, ejudge будет простаивать.
\end{itemize}

Рассмотрим подробнее оба способа.

\begin{center}
  \begin{longtable}{|p{0.40\textwidth}|p{0.20\textwidth}|p{0.30\textwidth}|}
    \caption{Способы решения проблемы обновления статусов в pynformatics.runs}
    \label{tab:longtable}
    \\ \hline
    Критерий & Триггер в БД & Сервис, ждущий обновления посылок \\
    \hline \endfirsthead
    \subcaption{Продолжение таблицы~\ref{tab:longtable}}
    \\ \hline \endhead
    \hline \subcaption{Продолжение на след. стр.}
    \endfoot
    \hline \endlastfoot
    Снижение производительности & Значительное & Незначительное \\
    \hline
    Сложность реализации    & Просто     & Сложно \\
    \hline
    Сложность поддержки & Просто     & Сложно \\
    \hline
  \end{longtable}
\end{center}

Был проведён эксперимент, реализующий подход с триггером, производительность БД упала очень значительно, поэтому финальным вариантом был выбран отдельный асинхронный сервис, ждущий информацию посылки посылки.

\subsection{Сервис, ждущий обновление посылки}

\label{lab:ejudge_listener}
Для начала, необходимо было понять, что нужно сделать, 
чтобы ejudge смог отправлять сообщение об обновлении посылки.
Было решено изменить код обновления статуса посылки таким образом, 
чтобы тот после обновления статуса тестирования БД исполнял дополнительный код,
оповещающий об изменении посылки. В листинге \ref{lst:ejudge_http_notify} представлен код, оповещающий об обновлении посылки.

Затем необходимо было выбрать протокол общения между ejudge и сервисом.
Для упрощения реализации вызываемого кода был выбран протокол HTTP.

Сервис, ждущий обновление посылки, был назван ejudge-listener.

\lstinputlisting[language=C,caption={Код, оповещающий об обновлении посылки},label=lst:ejudge_http_notify]{listings/ejudge_http_notify.c}

Код ejudge-listener был реализован с помощью языка программирования Python.
Для того, чтобы сделать ejudge-listener асинхронным, можно было выбрать один из следующих способов: 

% Celery vs RQ vs Асинхронщина

Так как обновление статуса посылки является критически важным функционалом системы,
и терять эту информацию -- недопустимо, было принято решение использовать фреймворк Celery.

Для инкапсуляции логики работы с таблицей pynformatics.run, 
доступ к ней есть только у сервиса Rmatics, 
поэтому ejudge-listener не обновляет данные этой таблицы самостоятельно,
вместо этого он передаёт по протоколу HTTP запрос на изменение посылки в Rmatics.

Полная схема работы ejudge-listeenr представлена на Рис. \ref{fig:ejudge_listener}.

